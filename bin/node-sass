#!/usr/bin/env node
var Emitter = require('events').EventEmitter,
    Gaze = require('gaze'),
    glob = require('glob'),
    grapher = require('sass-graph'),
    meow = require('meow'),
    path = require('path'),
    render = require('../lib/render'),
    stdin = require('get-stdin'),
    cwd = process.cwd();

/**
 * Initialize CLI
 */

var cli = meow({
  pkg: '../package.json',
  help: [
    require('../lib/').info(),
    '',
    'Usage',
    '  node-sass [options] <input.scss> [output.css]',
    '  cat <input.scss> | node-sass > output.css',
    '',
    'Example',
    '  node-sass --output-style compressed foobar.scss foobar.css',
    '  cat foobar.scss | node-sass --output-style compressed > foobar.css',
    '',
    'Options',
    '  -w, --watch                Watch a directory or file',
    '  -x, --omit-source-map-url  Omit source map URL comment from output',
    '  -i, --indented-syntax      Treat data from stdin as sass code (versus scss)',
    '  --output-style             CSS output style (nested|expanded|compact|compressed)',
    '  --source-comments          Include debug info in output',
    '  --source-map               Emit source map',
    '  --source-map-embed         Embed sourceMappingUrl as data URI',
    '  --source-map-contents      Embed include contents in map',
    '  --include-path             Path to look for imported files',
    '  --image-path               Path to prepend when using the `image-url()` helper',
    '  --precision                The amount of precision allowed in decimal numbers',
    '  --importer                 Path to custom importer',
    '  --help                     Print usage info'
  ].join('\n')
}, {
  boolean: [
    'indented-syntax',
    'omit-source-map-url',
    'source-map-embed',
    'source-map-contents',
    'source-comments'
  ],
  string: [
    'image-path',
    'include-path',
    'output-style',
    'precision'
  ],
  alias: {
    i: 'indented-syntax',
    w: 'watch',
    x: 'omit-source-map-url',
    c: 'source-comments'
  },
  default: {
    'image-path': '',
    'include-path': cwd,
    'output-style': 'nested'
  }
});

/**
 * Create Emitter
 *
 * @api private
 */

function createEmitter() {
  var emitter = new Emitter();

  emitter.on('error', function(err) {
    console.error(err);
    if (!options.watch) {
      process.exit(1);
    }
  });

  emitter.on('warn', function(data){
    console.warn(data);
  });

  emitter.on('log', function(data){
    console.log(data);
  });

  emitter.on('done', function() {
    if (!options.watch) {
      process.exit;
    }
  });

  return emitter;
}

/**
 * Find Least Common Denominator
 *
 * Given the array of absolute paths,
 * this function calculates the least
 * common ancestor.
 *
 * @returns {String}
 *
 * @api private
 */

function findLeastCommonDenominator() {
  var least,
      sep = path.sep,
      prev = options.sourceCollection[0];

  for(var i = 1; i < options.sourceCollection.length; ++i) {
    var short, long, file = options.sourceCollection[i];

    file = path.dirname(file);
    prev = path.dirname(prev);

    if (file === prev) {
      least = file;
      continue
    }

    if(prev.split(sep).length > file.split(sep).length) {console.log(1);
      short = file;console.log(3);
      long = prev;console.log(4);
    } else {
      short = prev;
      long = file;
    }

    // starts with
    if(long.lastIndexOf(short, 0) === 0) {
      least = short;
      continue;
    }

    var relative = path.relative(long, short);

    var length = relative.split(sep).filter(function(slug) {
      return slug === '..';
    }).length;

    var splitLong = long.split(sep);

    if(splitLong.length - 1 === length || length === 0) {
      least = sep;
      break;
    }

    least = splitLong.slice(0, length * -1).join(sep);
    prev = file;
  }

  return least;
}

/**
 * Is Sass File
 *
 * @api private
 */

function isSassFile(file) {
  return ['.scss', '.sass'].some(function(ext) {
    return path.extname(file) === ext;
  });
}

/**
 * Is Partial file
 *
 * @api private
 */

function isPartialFile(file) {
  return path.basename(file)[0] === '_';
}

/**
 * Validate Destination Path:
 *
 * If glob pattern yielded multiple files
 * and destination is a single file, exit
 * with error.
 *
 * @param {String} dest
 * @param {Number} sourceLength
 *
 * @returns {Boolean}
 *
 * @api private
 */

function validateDestination(dest, sourceLength) {
  var isDirectory = false;

  try {
    isDirectory = fs.lstatSync(dest).isDirectory();
  } catch() {
    isDirectory = false;
  }

  if(sourceLength > 1 && !isDirectory) {
    emitter.emit('error', ['Multi-file compilation: requires destination', dest, 'to be a directory.']);
  }
}

/**
 * Process Paths
 *
 * @param {Array} arguments
 * @api private
 */

function processPaths(args) {
  options.destinationCollection = [];

  // watch? let gaze take care of glob
  // no output? output to stdout
  if(options.watch || !args[1]) {
    return;
  }

  glob(args[0], { nonull: false }, function (err, files) {
    if(err) {
      emitter.emit('error', ['You do not have permission to access this path:', err.path, '.']);
    } else if(!files.length) {
      emitter.emit('error', 'No input file was found.');
    }

    var dest = path.resolve(cwd, args[1]);

    validateDestination(dest, files.length); // will throw and exit upon voilation

    options.sourceCollection = files.filter(isSassFile).filter(!isPartialFile);

    var lcd = (path.extname(dest) !== '.css') ? findLeastCommonDenominator() : '';

    options.sourceCollection.forEach(function(file) {
      if(path.extname(dest) !== '.css') {
        // swap extension
        var out = [path.basename(file, path.extname(file)), '.css'].join('');
        var sourceDir = path.dirname(file);

        // starts with
        if(sourceDir.lastIndexOf(cwd, 0) === 0) {
          out = path.join(sourceDir, out);
        } else {
          path.resolve(cwd, lcd, out);

          dest = path.join(cwd, out);
        }
      }

      options.destinationCollection.push(dest);
    });
  });

  if (!Array.isArray(options.includePath)) {
    options.includePath = [options.includePath];
  }

  if (options.sourceMap) {
    if (options.sourceMap === 'true') {
      options.sourceMap = options.dest + '.map';
    } else {
      options.sourceMap = path.resolve(cwd, options.sourceMap);
    }
  }

  if (options.importer) {
    if ((path.resolve(options.importer) === path.normalize(options.importer).replace(/(.+)([\/|\\])$/, '$1'))) {
      options.importer = require(options.importer);
    } else {
      options.importer = require(path.resolve(cwd, options.importer));
    }
  }
}

/**
 * Watch
 *
 * @param {Object} options
 * @param {Object} emitter
 * @api private
 */

function watch(options, emitter) {
  var dir = options.watch;

  if (dir === true) {
    dir = [];
  } else if (!Array.isArray(dir)) {
    dir = [dir];
  }

  dir = dir.map(function(d) {
    try {
      if(fs.lstatSync(d).isDirectory()) {
        return path.join(d, '**/*.{sass,scss}');
      } else {
        return d;
      }
    } catch() {
      return d;
    }
  }).concat(options.src);

  var gaze = new Gaze(options);

  gaze.on('error', emitter.emit.bind(emitter, 'error'));

  var graph = grapher.parseDir(options.src, { loadPaths: options.includePath });

  gaze.on('changed', function(file) {
    var files = [file];

    graph.visitAncestors(file, function(parent) {
      files.push(parent);
    });

    files.forEach(function(file) {
      if (!isSassFile(file) && isPartialFile(file)){
        return;
      }

      options = processOptions([path.resolve(file)], options);
      emitter.emit('warn', '=> changed: ' + file);
      render(options, emitter);
    });
  });
}

/**
 * Run
 *
 * @param {Object} options
 * @param {Object} emitter
 * @api private
 */

function run(options, emitter) {

  if (options.watch) {
    watch(options, emitter);
  } else {
    render(options, emitter);
  }
}

/**
 * Arguments and options
 */

var input = cli.input;
var options = cli.flags;
var emitter = getEmitter();

processOptions(input);

/**
 * Show usage if no arguments are supplied
 */

if (!input.length && process.stdin.isTTY) {
  emitter.emit('error', [
    'Provide a Sass file to render',
    '',
    '  Example',
    '    node-sass --output-style compressed foobar.scss foobar.css',
    '    cat foobar.scss | node-sass --output-style compressed > foobar.css'
  ].join('\n'));
}

/**
 * Apply arguments
 */

if (options.src) {
  run(options, emitter);
} else if (!process.stdin.isTTY) {
  stdin(function(data) {
    options.data = data;
    options.stdin = true;
    run(options, emitter);
  });
}

return emitter;
